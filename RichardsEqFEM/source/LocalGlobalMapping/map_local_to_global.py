# -*- coding: utf-8 -*-
"""
Created on Thu Aug 25 12:58:50 2022

@author: jakob
"""


import numpy as np
import math
from RichardsEqFEM.source.basisfunctions.lagrange_element import finite_element, global_element_geometry              
from RichardsEqFEM.source.basisfunctions.Gauss_quadrature_points import *
import porepy as pp



# Local -> Global node numbering lookup table
class Local_to_Global_table():
    
    def __init__(self,geometry, element):
        # Geometry is the geometry from porepy generated by pp.StructuredTriangle
        self.geometry = geometry 
        self.dim = geometry.dim
        self.element = element
        self.degree = self.element.degree 

        self.local_dofs = self.element.local_dofs
        
        # Nodes per element
        self.num_nodes_per_EL = int((self.degree+1)*(self.degree+2)/2)
        
        # Initialize list for the mapping.
        self.mapping = np.zeros((self.num_nodes_per_EL,self.geometry.num_cells),dtype=int)
        #print(self.geometry.num_cells)
        # Create list with global values;
        #         0 : The number of corner nodes
        #         1 : The number of faces
        #         2 : The number of cells
        self.global_vals = np.array([geometry.num_nodes,geometry.num_faces,geometry.num_cells])
        
        # Create list with nodes per geometric quantity
        #         0 : Number of proper nodes 
        #         1 : Number of nodes per face
        #         2 : Number of nodes within the element
        self.dofs_per_quantity = np.zeros(self.dim+1,dtype=int) # initialize
        
        
        
        # # Total number of nodes for any lagrange finite element
        
        
        # Geometric keyword dictionary
        self.geometry_keywords = {0:{'nodes'},1:{'faces'},2:{'elements'}}
        
        for i in self.geometry_keywords:
            for j in self.geometry_keywords[i]:
                for k in self.local_dofs[j]:
                    
                    self.dofs_per_quantity[i] = len(self.local_dofs[j][k])
                    
        # Total number of geometric points for any given lagrange finite element.
        self.total_geometric_pts = int(np.dot(self.dofs_per_quantity,self.global_vals))
        
        self.points_glob   = self.geometry.nodes
        
        # Generate map
        for e in range(self.geometry.num_cells):
            elements = geometry.cell_nodes()
            cell_node_list = elements.indices[elements.indptr[e] : elements.indptr[e+1]]
            # For P2 this is valid, extension for P3 requires work
            faces_of_cell = geometry.cell_faces.indices[geometry.cell_faces.indptr[e] : geometry.cell_faces.indptr[e+1]] \
                            + geometry.num_nodes
                            
                                  
            # Quick fix of rotation 
            if (e) % 2:
                
                idx = [0, 2, 1]
                cell_node_list = cell_node_list[idx]
                idx = [1, 0, 2]
                faces_of_cell  = faces_of_cell[idx]
                
            else:
                None
            
            
            
            for i in self.geometry_keywords:
                for j in self.geometry_keywords[i]:
                    for k in self.local_dofs[j]:
                        #print(i,j,k)
                        local = self.local_dofs[j][k]
                        #print(local)
                        if j =='nodes':
                            self.mapping[local,e] = cell_node_list[k]
                        if j =='faces':
                            self.mapping[local,e] = faces_of_cell[k]
                        # TODO: add what happens with elements.
                        
                        # if local is tuple... which it is for P3 elements on
                        # the faces.
            cn = cell_node_list
     
            corners = self.points_glob[0:2,cn]  
            
            self.PK_phys_element =global_element_geometry(self.element,corners,self.geometry,self.degree)
            self.coordsQQ = self.PK_phys_element.element_coord                        
            #self.points_glob[:,self.mapping[:,e] ]
                        
        oo = list(self.local_dofs['nodes'].values())
        flat_list = [item for sublist in oo for item in sublist]


        flat_list[1],flat_list[2] = flat_list[2],flat_list[1]
        
        self.local_dofs_corners = flat_list
        
        # Boundary points numbering
        if self.degree == 2:
            
            self.b_faces = geometry.tags['domain_boundary_faces'].nonzero()[0] +geometry.num_nodes
            self.b_nodes = geometry.tags['domain_boundary_nodes'].nonzero()[0]
        
            self.boundary = np.append(self.b_nodes,self.b_faces)
        else:
            self.boundary = geometry.tags['domain_boundary_nodes'].nonzero()[0]
            
        if self.degree ==2:
            self.coords_fit_to_local_global_table(self.geometry,self.degree)
            
            
    def orientation(self,coords):
         
        # to find the orientation of
        # an ordered triplet (p1,p2,p3)
        # function returns the following values:
        # 0 : Collinear points
        # 1 : Clockwise points
        # 2 : Counterclockwise
        val = (float(coords[1][1] - coords[1][0]) * (coords[0][2] - coords[0][1])) - \
               (float(coords[0][1] - coords[0][0]) * (coords[1][2] - coords[1][1]))
        if (val > 0):
             
            # Clockwise orientation
            return 1
        elif (val < 0):
             
            # Counterclockwise orientation
            return 2
        else:
                  
            # Collinear orientation
            return 0
    def coordinates_sorted(self,g,order):    
        coords = g.nodes[0:2]
        #print(coords)
        face_centers = g.face_centers[0:2]
        xcoord = np.concatenate((coords[0],face_centers[0]))
        ycoord = np.concatenate((coords[1],face_centers[1]))
        
        coordinates = np.concatenate([xcoord,ycoord]).reshape(2,len(xcoord))
        
        return coordinates

                
    
    def coords_fit_to_local_global_table(self,g,order):
        Initial_coordinates=self.coordinates_sorted(g,1)
     
        loc_glob_table = self.mapping
        
        # Rotation check of edges only.
        for e in range(g.num_cells):
            #print(e)
            coords_at_element= Initial_coordinates[:,loc_glob_table[:,e]]
            idx = [1,3,5]
            face_coords = coords_at_element[:,idx]
            idx_smallest_x = np.argmin(face_coords[0])
            idx_smallest_y = np.argmin(face_coords[1])
            orientation_val = self.orientation(face_coords)
            
            if orientation_val== 1: # clockwise orientaion
                
                if idx_smallest_x==1:
                    None
                    
                
                elif idx_smallest_x==2:
                  
                    new_idx = [3,5,1]
                    self.mapping[:,e][new_idx]= self.mapping[:,e][idx] # update map 
                   
                else:
                    if (e%2)==0:
                        
                        if idx_smallest_y == 2:
                        
                           
                            None
                        
               
                        elif idx_smallest_y == 1:
                            
                    
                            None
                        else:
                           
                            new_idx = [5,1,3]
                            self.mapping[:,e][new_idx]= self.mapping[:,e][idx] # update map 
                            
                            
            elif orientation_val== 2: # counterclockwise orientaion
               
                
                if idx_smallest_x==1:
                    None
                elif idx_smallest_x==2:
                    
                    new_idx = [5,3,1]
                    self.mapping[:,e][new_idx]= self.mapping[:,e][idx] # update map 
                    
                  
                else:
                    if idx_smallest_y == 0:
                        
                        new_idx = [5,3,1]
                        self.mapping[:,e][new_idx]= self.mapping[:,e][idx] # update map 
                        
               
                    elif idx_smallest_y == 1:
                        
                        print('issue wrong smmal y')
                    else:
                       
                        print('issue wrong rotation')
            else: # colinear orientation, used for P3
                None
          
               
        
